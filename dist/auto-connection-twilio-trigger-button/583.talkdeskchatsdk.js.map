{"version":3,"file":"583.talkdeskchatsdk.js","mappings":"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","sources":["webpack://TalkdeskChatSDK/./node_modules/@newrelic/browser-agent-core/common/event-emitter/register-handler.js","webpack://TalkdeskChatSDK/./node_modules/@newrelic/browser-agent-core/common/serialize/bel-serializer.js","webpack://TalkdeskChatSDK/./node_modules/@newrelic/browser-agent-core/features/page-view-timing/aggregate/index.js"],"sourcesContent":["/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { handleEE, globalEE } from './handle'\n\n// export default defaultRegister\nexport { globalRegister as global }\nexport { defaultRegister as registerHandler }\n\ndefaultRegister.on = registerWithSpecificEmitter\n\nvar handlers = defaultRegister.handlers = {}\nvar globalHandlers = globalRegister.handlers = {}\n\nexport function defaultRegister (type, handler, group, ee) {\n  registerWithSpecificEmitter(ee || handleEE, handlers, type, handler, group)\n}\n\nfunction globalRegister (type, handler, group) {\n  registerWithSpecificEmitter(globalEE, globalHandlers, type, handler, group)\n}\n\nfunction registerWithSpecificEmitter (ee, handlers, type, handler, group) {\n  if (!group) group = 'feature'\n  if (!ee) ee = handleEE\n\n  if (ee.isBuffering(type)) {\n    var groupHandlers = handlers[group] = handlers[group] || {}\n    var list = groupHandlers[type] = groupHandlers[type] || []\n    list.push([ee, handler])\n  } else {\n    ee.on(type, handler)\n  }\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { mapOwn } from '../util/map-own'\nimport { stringify } from '../util/stringify'\nimport { Obfuscator } from '../util/obfuscate'\n\nvar hasOwnProp = Object.prototype.hasOwnProperty\nvar MAX_ATTRIBUTES = 64\n\n// export default {\n//   nullable,\n//   numeric,\n//   getAddStringContext,\n//   addCustomAttributes\n// }\n\nexport function nullable (val, fn, comma) {\n  return val || val === 0 || val === ''\n    ? fn(val) + (comma ? ',' : '')\n    : '!'\n}\n\nexport function numeric (n, noDefault) {\n  if (noDefault) {\n    return Math.floor(n).toString(36)\n  }\n  return (n === undefined || n === 0) ? '' : Math.floor(n).toString(36)\n}\n\nexport function getAddStringContext (agentIdentifier) {\n  // eslint-disable-next-line\n  var stringTable = Object.hasOwnProperty('create') ? Object.create(null) : {}\n  var stringTableIdx = 0\n\n  return addString\n\n  function addString(str) {\n    if (typeof str === 'undefined' || str === '') return ''\n    var obfuscator = new Obfuscator({agentIdentifier: agentIdentifier})\n    str = String(str)\n    if (obfuscator.shouldObfuscate()) str = obfuscator.obfuscateString(str)\n    if (hasOwnProp.call(stringTable, str)) {\n      return numeric(stringTable[str], true)\n    } else {\n      stringTable[str] = stringTableIdx++\n      return quoteString(str)\n    }\n  }\n}\n\nexport function addCustomAttributes (attrs, addString) {\n  var attrParts = []\n\n  mapOwn(attrs, function (key, val) {\n    if (attrParts.length >= MAX_ATTRIBUTES) return\n    var type = 5\n    var serializedValue\n    // add key to string table first\n    key = addString(key)\n\n    switch (typeof val) {\n      case 'object':\n        if (val) {\n          // serialize objects to strings\n          serializedValue = addString(stringify(val))\n        } else {\n          // null attribute type\n          type = 9\n        }\n        break\n      case 'number':\n        type = 6\n        // make sure numbers contain a `.` so they are parsed as doubles\n        serializedValue = val % 1 ? val : val + '.'\n        break\n      case 'boolean':\n        type = val ? 7 : 8\n        break\n      case 'undefined':\n        // we treat undefined as a null attribute (since dirac does not have a concept of undefined)\n        type = 9\n        break\n      default:\n        serializedValue = addString(val)\n    }\n\n    attrParts.push([type, key + (serializedValue ? ',' + serializedValue : '')])\n  })\n\n  return attrParts\n}\n\nvar escapable = /([,\\\\;])/g\n\nfunction quoteString (str) {\n  return \"'\" + str.replace(escapable, '\\\\$1')\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { nullable, numeric, getAddStringContext, addCustomAttributes } from '../../../common/serialize/bel-serializer'\nimport { now } from '../../../common/timing/now'\nimport { mapOwn } from '../../../common/util/map-own'\nimport { HarvestScheduler } from '../../../common/harvest/harvest-scheduler'\nimport { defaultRegister as register } from '../../../common/event-emitter/register-handler'\nimport { cleanURL } from '../../../common/url/clean-url'\nimport { handle } from '../../../common/event-emitter/handle'\nimport { getInfo } from '../../../common/config/config'\nimport { FeatureBase } from '../../../common/util/feature-base'\nexport class Aggregate extends FeatureBase {\n  constructor(agentIdentifier, aggregator) {\n    super(agentIdentifier, aggregator)\n    this.timings = []\n    this.timingsSent = []\n    this.lcpRecorded = false\n    this.lcp = null\n    this.clsSupported = false\n    this.cls = 0\n    this.clsSession = {value: 0, firstEntryTime: 0, lastEntryTime: 0}\n    this.pageHideRecorded = false\n\n    this.harvestTimeSeconds = 30\n\n    try {\n      clsSupported = PerformanceObserver.supportedEntryTypes.includes('layout-shift') // eslint-disable-line no-undef\n    } catch (e) {\n    // do nothing\n    }\n\n    if (!this.options) this.options = {}\n    var maxLCPTimeSeconds = this.options.maxLCPTimeSeconds || 60\n    var initialHarvestSeconds = this.options.initialHarvestSeconds || 10\n    this.harvestTimeSeconds = this.options.harvestTimeSeconds || 30\n\n    this.scheduler = new HarvestScheduler('events', {\n      onFinished: (...args) => this.onHarvestFinished(...args),\n      getPayload: (...args) => this.prepareHarvest(...args),\n      onUnload: () => this.finalHarvest()\n    }, this)\n\n    register('timing', (...args) => this.processTiming(...args), undefined, this.ee)\n    register('lcp', (...args) => this.updateLatestLcp(...args), undefined, this.ee)\n    register('cls', (...args) => this.updateClsScore(...args), undefined, this.ee)\n    register('pageHide', (...args) => this.updatePageHide(...args), undefined, this.ee)\n\n    // final harvest is initiated from the main agent module, but since harvesting\n    // here is not initiated by the harvester, we need to subscribe to the unload event\n    // separately\n    // subscribeToUnload((...args) => this.finalHarvest(...args))\n\n    // After 1 minute has passed, record LCP value if no user interaction has occurred first\n    setTimeout(() => {\n      this.recordLcp()\n      this.lcpRecorded = true\n    }, maxLCPTimeSeconds * 1000)\n\n    // send initial data sooner, then start regular\n    this.scheduler.startTimer(this.harvestTimeSeconds, initialHarvestSeconds)\n  }\n\n  recordLcp() {\n    if (!this.lcpRecorded && this.lcp !== null) {\n      var lcpEntry = this.lcp[0]\n      var cls = this.lcp[1]\n      var networkInfo = this.lcp[2]\n\n      var attrs = {\n        'size': lcpEntry.size,\n        'eid': lcpEntry.id\n      }\n\n      if (networkInfo) {\n        if (networkInfo['net-type']) attrs['net-type'] = networkInfo['net-type']\n        if (networkInfo['net-etype']) attrs['net-etype'] = networkInfo['net-etype']\n        if (networkInfo['net-rtt']) attrs['net-rtt'] = networkInfo['net-rtt']\n        if (networkInfo['net-dlink']) attrs['net-dlink'] = networkInfo['net-dlink']\n      }\n\n      if (lcpEntry.url) {\n        attrs['elUrl'] = cleanURL(lcpEntry.url)\n      }\n\n      if (lcpEntry.element && lcpEntry.element.tagName) {\n        attrs['elTag'] = lcpEntry.element.tagName\n      }\n\n      // collect 0 only when CLS is supported, since 0 is a valid score\n      if (cls > 0 || this.clsSupported) {\n        attrs['cls'] = cls\n      }\n\n      this.addTiming('lcp', Math.floor(lcpEntry.startTime), attrs, false)\n      this.lcpRecorded = true\n    }\n  }\n\n  updateLatestLcp(lcpEntry, networkInformation) {\n    if (this.lcp) {\n      var previous = this.lcp[0]\n      if (previous.size >= lcpEntry.size) {\n        return\n      }\n    }\n\n    this.lcp = [lcpEntry, this.cls, networkInformation]\n  }\n\n  updateClsScore(clsEntry) {\n  // this used to be cumulative for the whole page, now we need to split it to a\n  // new CLS measurement after 1s between shifts or 5s total\n    if ((clsEntry.startTime - this.clsSession.lastEntryTime) > 1000 ||\n      (clsEntry.startTime - this.clsSession.firstEntryTime) > 5000) {\n      this.clsSession = {value: 0, firstEntryTime: clsEntry.startTime, lastEntryTime: clsEntry.startTime}\n    }\n\n    this.clsSession.value += clsEntry.value\n    this.clsSession.lastEntryTime = Math.max(this.clsSession.lastEntryTime, clsEntry.startTime)\n\n    // only keep the biggest CLS we've observed\n    if (this.cls < this.clsSession.value) this.cls = this.clsSession.value\n  }\n\n  updatePageHide(timestamp) {\n    if (!this.pageHideRecorded) {\n      this.addTiming('pageHide', timestamp, null, true)\n      this.pageHideRecorded = true\n    }\n  }\n\n  recordUnload() {\n    this.updatePageHide(now())\n    this.addTiming('unload', now(), null, true)\n  }\n\n  addTiming(name, value, attrs, addCls) {\n    attrs = attrs || {}\n    // collect 0 only when CLS is supported, since 0 is a valid score\n    if ((this.cls > 0 || this.clsSupported) && addCls) {\n      attrs['cls'] = this.cls\n    }\n\n    this.timings.push({\n      name: name,\n      value: value,\n      attrs: attrs\n    })\n\n    handle('pvtAdded', [name, value, attrs])\n  }\n\n  processTiming(name, value, attrs) {\n  // Upon user interaction, the Browser stops executing LCP logic, so we can send here\n  // We're using setTimeout to give the Browser time to finish collecting LCP value\n    if (name === 'fi') {\n      setTimeout(this.recordLcp, 0)\n    }\n\n    this.addTiming(name, value, attrs, true)\n  }\n\n  onHarvestFinished(result) {\n    if (result.retry && this.timingsSent.length > 0) {\n      for (var i = 0; i < this.timingsSent.length; i++) {\n        this.timings.push(this.timingsSent[i])\n      }\n      this.timingsSent = []\n    }\n  }\n\n  finalHarvest() {\n    this.recordLcp()\n    this.recordUnload()\n    var payload = this.prepareHarvest({ retry: false })\n    this.scheduler.harvest.send('events', payload, { unload: true })\n  }\n\n  appendGlobalCustomAttributes(timing) {\n    var timingAttributes = timing.attrs || {}\n    var customAttributes = getInfo(this.agentIdentifier).jsAttributes || {}\n\n    var reservedAttributes = ['size', 'eid', 'cls', 'type', 'fid', 'elTag', 'elUrl', 'net-type',\n      'net-etype', 'net-rtt', 'net-dlink']\n    mapOwn(customAttributes, function (key, val) {\n      if (reservedAttributes.indexOf(key) < 0) {\n        timingAttributes[key] = val\n      }\n    })\n  }\n\n  // serialize and return current timing data, clear and save current data for retry\n  prepareHarvest(options) {\n    if (this.timings.length === 0) return\n\n    var payload = this.getPayload(this.timings)\n    if (options.retry) {\n      for (var i = 0; i < this.timings.length; i++) {\n        this.timingsSent.push(this.timings[i])\n      }\n    }\n    this.timings = []\n    return { body: { e: payload } }\n  }\n\n  // serialize array of timing data\n  getPayload(data) {\n    var addString = getAddStringContext()\n\n    var payload = 'bel.6;'\n\n    for (var i = 0; i < data.length; i++) {\n      var timing = data[i]\n\n      payload += 'e,'\n      payload += addString(timing.name) + ','\n      payload += nullable(timing.value, numeric, false) + ','\n\n      this.appendGlobalCustomAttributes(timing)\n\n      var attrParts = addCustomAttributes(timing.attrs, addString)\n      if (attrParts && attrParts.length > 0) {\n        payload += numeric(attrParts.length) + ';' + attrParts.join(';')\n      }\n\n      if ((i + 1) < data.length) payload += ';'\n    }\n\n    return payload\n  }\n}\n\n"],"names":["defaultRegister","on","registerWithSpecificEmitter","handlers","globalHandlers","globalRegister","type","handler","group","ee","isBuffering","groupHandlers","push","hasOwnProp","Object","prototype","hasOwnProperty","MAX_ATTRIBUTES","nullable","val","fn","comma","numeric","n","noDefault","Math","floor","toString","undefined","getAddStringContext","agentIdentifier","stringTable","create","stringTableIdx","addString","str","obfuscator","String","shouldObfuscate","obfuscateString","call","quoteString","replace","escapable","addCustomAttributes","attrs","attrParts","key","length","serializedValue","Aggregate","constructor","aggregator","super","this","timings","timingsSent","lcpRecorded","lcp","clsSupported","cls","clsSession","value","firstEntryTime","lastEntryTime","pageHideRecorded","harvestTimeSeconds","PerformanceObserver","supportedEntryTypes","includes","e","options","maxLCPTimeSeconds","initialHarvestSeconds","scheduler","onFinished","args","onHarvestFinished","getPayload","prepareHarvest","onUnload","finalHarvest","processTiming","updateLatestLcp","updateClsScore","updatePageHide","setTimeout","recordLcp","startTimer","lcpEntry","networkInfo","size","id","url","element","tagName","addTiming","startTime","networkInformation","clsEntry","max","timestamp","recordUnload","name","addCls","result","retry","i","payload","harvest","send","unload","appendGlobalCustomAttributes","timing","timingAttributes","customAttributes","jsAttributes","reservedAttributes","indexOf","body","data","join"],"sourceRoot":""}