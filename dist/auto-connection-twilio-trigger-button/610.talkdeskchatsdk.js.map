{"version":3,"file":"610.talkdeskchatsdk.js","mappings":"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","sources":["webpack://TalkdeskChatSDK/./node_modules/@newrelic/browser-agent-core/common/event-emitter/contextual-ee.js","webpack://TalkdeskChatSDK/./node_modules/@newrelic/browser-agent-core/common/util/feature-base.js","webpack://TalkdeskChatSDK/./node_modules/@newrelic/browser-agent-core/common/util/get-or-set.js","webpack://TalkdeskChatSDK/./node_modules/@newrelic/browser-agent-core/features/page-action/instrument/index.js"],"sourcesContent":["/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { gosNREUM } from '../window/nreum'\nimport { getOrSet } from '../util/get-or-set'\nimport { mapOwn } from '../util/map-own'\n\nvar ctxId = 'nr@context'\n\n// create global emitter instance that can be shared among bundles\nlet nr = gosNREUM()\nvar globalInstance\nif (nr.ee) {\n  globalInstance = nr.ee\n} else {\n  globalInstance = ee(undefined, 'globalEE')\n  nr.ee = globalInstance\n}\n\n// export default ee()\nvar baseEE = ee(undefined, 'baseEE')\n\nexport { baseEE as ee }\n\nexport { globalInstance as global }\n\nfunction EventContext () {}\n\nfunction ee (old, debugId) {\n  var handlers = {}\n  var bufferGroupMap = {}\n  var emitters = {}\n\n  var emitter = {\n    on: addEventListener,\n    addEventListener: addEventListener,\n    removeEventListener: removeEventListener,\n    emit: emit,\n    get: getOrCreate,\n    listeners: listeners,\n    context: context,\n    buffer: bufferEventsByGroup,\n    abort: abortIfNotLoaded,\n    aborted: false,\n    isBuffering: isBuffering,\n    debugId\n  }\n\n  // buffer is associated with a base emitter, since there are two\n  // (global and scoped to the current bundle), it is now part of the emitter\n  if (!old) {\n    emitter.backlog = {}\n  }\n\n  return emitter\n\n  function context (contextOrStore) {\n    if (contextOrStore && contextOrStore instanceof EventContext) {\n      return contextOrStore\n    } else if (contextOrStore) {\n      return getOrSet(contextOrStore, ctxId, getNewContext)\n    } else {\n      return getNewContext()\n    }\n  }\n\n  function emit (type, args, contextOrStore, force, bubble) {\n    if (bubble !== false) bubble = true\n    if (baseEE.aborted && !force) { return }\n    if (old && bubble) old.emit(type, args, contextOrStore)\n    // log(\"continue...\")\n\n    var ctx = context(contextOrStore)\n    var handlersArray = listeners(type)\n    var len = handlersArray.length\n\n    // Extremely verbose debug logging\n    // if ([/^xhr/].map(function (match) {return type.match(match)}).filter(Boolean).length) {\n    //  log(type + ' args:')\n    //  log(args)\n    //  log(type + ' handlers array:')\n    //  log(handlersArray)\n    //  log(type + ' context:')\n    //  log(ctx)\n    //  log(type + ' ctxStore:')\n    //  log(ctxStore)\n    // }\n\n    // Apply each handler function in the order they were added\n    // to the context with the arguments\n\n    for (var i = 0; i < len; i++) handlersArray[i].apply(ctx, args)\n\n    // log(bufferGroupMap[type])\n    // Buffer after emitting for consistent ordering\n    var bufferGroup = getBuffer()[bufferGroupMap[type]]\n    if (bufferGroup) {\n      bufferGroup.push([emitter, type, args, ctx])\n    }\n\n    // log(bufferGroup)\n\n    // Return the context so that the module that emitted can see what was done.\n    return ctx\n  }\n\n  function addEventListener (type, fn) {\n    // Retrieve type from handlers, if it doesn't exist assign the default and retrieve it.\n    handlers[type] = listeners(type).concat(fn)\n  }\n\n  function removeEventListener (type, fn) {\n    var listeners = handlers[type]\n    if (!listeners) return\n    for (var i = 0; i < listeners.length; i++) {\n      if (listeners[i] === fn) {\n        listeners.splice(i, 1)\n      }\n    }\n  }\n\n  function listeners (type) {\n    return handlers[type] || []\n  }\n\n  function getOrCreate (name) {\n    return (emitters[name] = emitters[name] || ee(emitter, name))\n  }\n\n  function bufferEventsByGroup (types, group) {\n    var eventBuffer = getBuffer()\n\n    // do not buffer events if agent has been aborted\n    if (emitter.aborted) return\n    mapOwn(types, function (i, type) {\n      group = group || 'feature'\n      bufferGroupMap[type] = group\n      if (!(group in eventBuffer)) {\n        eventBuffer[group] = []\n      }\n    })\n  }\n\n  function isBuffering(type) {\n    var bufferGroup = getBuffer()[bufferGroupMap[type]]\n    return !!bufferGroup\n  }\n\n  // buffer is associated with a base emitter, since there are two\n  // (global and scoped to the current bundle), it is now part of the emitter\n  function getBuffer() {\n    if (old) {\n      return old.backlog\n    }\n    return emitter.backlog\n  }\n}\n\n// get context object from store object, or create if does not exist\nexport function getOrSetContext(obj) {\n  return getOrSet(obj, ctxId, getNewContext)\n}\n\nfunction getNewContext () {\n  return new EventContext()\n}\n\n// abort should be called 30 seconds after the page has started running\n// We should drop our data and stop collecting if we still have a backlog, which\n// signifies the rest of the agent wasn't loaded\nfunction abortIfNotLoaded () {\n  if (baseEE.backlog.api || baseEE.backlog.feature) {\n    baseEE.aborted = true\n    baseEE.backlog = {}\n  }\n}\n","import {ee} from '../event-emitter/contextual-ee'\n\nexport class FeatureBase {\n  constructor(agentIdentifier, aggregator) {\n    this.agentIdentifier = agentIdentifier\n    this.aggregator = aggregator\n    this.ee = ee.get(agentIdentifier)\n  }\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar has = Object.prototype.hasOwnProperty\n\n// export default getOrSet\n\n// Always returns the current value of obj[prop], even if it has to set it first\nexport function getOrSet (obj, prop, getVal) {\n  // If the value exists return it.\n  if (has.call(obj, prop)) return obj[prop]\n\n  var val = getVal()\n\n  // Attempt to set the property so it's not enumerable\n  if (Object.defineProperty && Object.keys) {\n    try {\n      Object.defineProperty(obj, prop, {\n        value: val, // old IE inherits non-write-ability\n        writable: true,\n        enumerable: false\n      })\n\n      return val\n    } catch (e) {\n      // Can't report internal errors,\n      // because GOS is a dependency of the reporting mechanisms\n    }\n  }\n\n  // fall back to setting normally\n  obj[prop] = val\n  return val\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// Turn on feature\nimport { getRuntime } from '../../../common/config/config'\nimport { FeatureBase } from '../../../common/util/feature-base'\n\nexport class Instrument extends FeatureBase {\n  constructor(agentIdentifier) {\n    super(agentIdentifier)\n\n    if (!getRuntime(this.agentIdentifier).disabled) getRuntime(this.agentIdentifier).features.ins = true\n  }\n}\n"],"names":["ctxId","nr","globalInstance","ee","undefined","baseEE","EventContext","old","debugId","handlers","bufferGroupMap","emitters","emitter","on","addEventListener","removeEventListener","type","fn","listeners","i","length","splice","emit","args","contextOrStore","force","bubble","aborted","ctx","context","handlersArray","len","apply","bufferGroup","getBuffer","push","get","getOrCreate","name","buffer","bufferEventsByGroup","types","group","eventBuffer","abort","abortIfNotLoaded","isBuffering","backlog","getNewContext","concat","api","feature","FeatureBase","constructor","agentIdentifier","aggregator","this","has","Object","prototype","hasOwnProperty","getOrSet","obj","prop","getVal","call","val","defineProperty","keys","value","writable","enumerable","e","Instrument","super","disabled","features","ins"],"sourceRoot":""}