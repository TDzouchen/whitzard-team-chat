{"version":3,"file":"228.talkdeskchatsdk.js","mappings":"qNASIA,EAAQ,aAGZ,IAAIC,GAAK,UACT,IAAIC,EACAD,EAAGE,GACLD,EAAiBD,EAAGE,IAEpBD,EAAiBC,QAAGC,EAAW,YAC/BH,EAAGE,GAAKD,GAIV,IAAIG,EAASF,QAAGC,EAAW,UAM3B,SAASE,eAAiB,CAE1B,SAASH,GAAII,EAAKC,GAChB,IAAIC,EAAW,CAAC,EACZC,EAAiB,CAAC,EAClBC,EAAW,CAAC,EAEZC,EAAU,CACZC,GAAIC,iBACJA,iBAAkBA,iBAClBC,oBA2EF,SAASA,oBAAqBC,EAAMC,GAClC,IAAIC,EAAYT,EAASO,GACzB,IAAKE,EAAW,OAChB,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAUE,OAAQD,IAChCD,EAAUC,KAAOF,GACnBC,EAAUG,OAAOF,EAAG,EAG1B,EAlFEG,KA6BF,SAASA,KAAMN,EAAMO,EAAMC,EAAgBC,EAAOC,IACjC,IAAXA,IAAkBA,GAAS,GAC/B,GAAIrB,EAAOsB,UAAYF,EAAS,OAC5BlB,GAAOmB,GAAQnB,EAAIe,KAAKN,EAAMO,EAAMC,GAsBxC,IAnBA,IAAII,EAAMC,QAAQL,GACdM,EAAgBZ,UAAUF,GAC1Be,EAAMD,EAAcV,OAiBfD,EAAI,EAAGA,EAAIY,EAAKZ,IAAKW,EAAcX,GAAGa,MAAMJ,EAAKL,GAI1D,IAAIU,EAAcC,YAAYxB,EAAeM,IACzCiB,GACFA,EAAYE,KAAK,CAACvB,EAASI,EAAMO,EAAMK,IAMzC,OAAOA,CACT,EAlEEQ,IAuFF,SAASC,YAAaC,GACpB,OAAQ3B,EAAS2B,GAAQ3B,EAAS2B,IAASnC,GAAGS,EAAS0B,EACzD,EAxFEpB,UAAWA,UACXW,QAASA,QACTU,OAwFF,SAASC,oBAAqBC,EAAOC,GACnC,IAAIC,EAAcT,YAGlB,GAAItB,EAAQe,QAAS,QACrB,OAAOc,GAAO,SAAUtB,EAAGH,GACzB0B,EAAQA,GAAS,UACjBhC,EAAeM,GAAQ0B,EACjBA,KAASC,IACbA,EAAYD,GAAS,GAEzB,GACF,EAnGEE,MAAOC,iBACPlB,SAAS,EACTmB,YAmGF,SAASA,YAAY9B,GAEnB,QADkBkB,YAAYxB,EAAeM,GAE/C,EArGER,WASF,OAJKD,IACHK,EAAQmC,QAAU,CAAC,GAGdnC,EAEP,SAASiB,QAASL,GAChB,OAAIA,GAAkBA,aAA0BlB,aACvCkB,EACEA,GACF,OAASA,EAAgBxB,EAAOgD,eAEhCA,eAEX,CA0CA,SAASlC,iBAAkBE,EAAMC,GAE/BR,EAASO,GAAQE,UAAUF,GAAMiC,OAAOhC,EAC1C,CAYA,SAASC,UAAWF,GAClB,OAAOP,EAASO,IAAS,EAC3B,CA2BA,SAASkB,YACP,OAAI3B,EACKA,EAAIwC,QAENnC,EAAQmC,OACjB,CACF,CAOA,SAASC,gBACP,OAAO,IAAI1C,YACb,CAKA,SAASuC,oBACHxC,EAAO0C,QAAQG,KAAO7C,EAAO0C,QAAQI,WACvC9C,EAAOsB,SAAU,EACjBtB,EAAO0C,QAAU,CAAC,EAEtB,C,4HC3KWK,EAAW,EAAAjD,GAAMiC,IAAI,UACrBiB,EAAW,IAAOjB,IAAI,UAM1B,SAASkB,OAAOtC,EAAMO,EAAMK,EAAKc,EAAOvC,GACzCA,GACFA,EAAGoC,OAAO,CAACvB,GAAO0B,GAClBvC,EAAGmB,KAAKN,EAAMO,EAAMK,KAEpBwB,EAASb,OAAO,CAACvB,GAAO0B,GACxBU,EAAS9B,KAAKN,EAAMO,EAAMK,GAE9B,C,wECrBA,IAAI2B,GAAkB,EACtB,IACE,IAAIC,EAAOC,OAAOC,eAAe,CAAC,EAAG,UAAW,CAE9CtB,IAAK,WACHmB,GAAkB,CACpB,IAEFI,OAAO7C,iBAAiB,cAAe,KAAM0C,GAC7CG,OAAO5C,oBAAoB,cAAe,KAAMyC,EAClD,CAAE,MAAOI,GAET,CAEO,SAASC,kBAAkBC,GAChC,OAAOP,EAAkB,CAACQ,SAAS,EAAMC,UAAWF,KAAgBA,CACtE,C,iFCdO,MAAMG,YACX,WAAAC,CAAYC,EAAiBC,GAC3BC,KAAKF,gBAAkBA,EACvBE,KAAKD,WAAaA,EAClBC,KAAKlE,GAAK,EAAAA,GAAGiC,IAAI+B,EACnB,E,+DCFF,IAAIG,EAAMb,OAAOc,UAAUC,eAKpB,SAASC,SAAUC,EAAKC,EAAMC,GAEnC,GAAIN,EAAIO,KAAKH,EAAKC,GAAO,OAAOD,EAAIC,GAEpC,IAAIG,EAAMF,IAGV,GAAInB,OAAOC,gBAAkBD,OAAOsB,KAClC,IAOE,OANAtB,OAAOC,eAAegB,EAAKC,EAAM,CAC/BK,MAAOF,EACPG,UAAU,EACVC,YAAY,IAGPJ,CACT,CAAE,MAAOlB,GAGT,CAKF,OADAc,EAAIC,GAAQG,EACLA,CACT,C,gICjCA,MAAMK,EAAMxB,OACNyB,EAAMD,EAAIE,SACVC,EAAqB,mBACrBC,EAAe,cAErB,SAASC,YAAaC,GACG,aAAnBL,EAAIM,YAA2BD,GACrC,CCHO,MAAME,mBAAmB,IAC9B,WAAAzB,CAAYC,GACVyB,MAAMzB,IACN,EAAAb,EAAA,IAAO,OAAQ,CAAC,aAAa,WAAqB,KAAM,MAAOe,KAAKlE,IDEjE,SAAS0F,aAAaJ,GACvBL,EAAIE,GAAqBH,EAAIG,GAAoB,OAAQG,GAAI,QAAkB,IAC9EN,EAAII,GAAc,SAAUE,EACnC,CCHII,EAAa,IAAMxB,KAAKyB,wBDKrB,SAASC,mBAAmBN,GAC7BL,EAAIE,GAAqBF,EAAIE,GAAoB,mBAAoBG,GAAI,QAAkB,IAC1FL,EAAIG,GAAc,qBAAsBC,YAC/C,CCPIO,EAAmB,IAAM1B,KAAK2B,2BAChC,CAEA,mBAAAF,GACE,IAAIG,GAAK,EAAAC,EAAA,OACT,EAAA5C,EAAA,IAAO,OAAQ,CAAC,SAAU2C,GAAK,WAAc,KAAM,MAAO5B,KAAKlE,KAC/D,EAAAmD,EAAA,IAAO,SAAU,CAAC,OAAQ2C,QAAK7F,OAAWA,EAAWiE,KAAKlE,GAC5D,CAEA,uBAAA6F,IACE,EAAA1C,EAAA,IAAO,OAAQ,CAAC,cAAc,EAAA4C,EAAA,OAAQ,WAAc,KAAM,MAAO7B,KAAKlE,GACxE,E","sources":["webpack://TalkdeskChatSDK/./node_modules/@newrelic/browser-agent-core/common/event-emitter/contextual-ee.js","webpack://TalkdeskChatSDK/./node_modules/@newrelic/browser-agent-core/common/event-emitter/handle.js","webpack://TalkdeskChatSDK/./node_modules/@newrelic/browser-agent-core/common/event-listener/event-listener-opts.js","webpack://TalkdeskChatSDK/./node_modules/@newrelic/browser-agent-core/common/util/feature-base.js","webpack://TalkdeskChatSDK/./node_modules/@newrelic/browser-agent-core/common/util/get-or-set.js","webpack://TalkdeskChatSDK/./node_modules/@newrelic/browser-agent-core/common/window/load.js","webpack://TalkdeskChatSDK/./node_modules/@newrelic/browser-agent-core/features/page-view-event/instrument/index.js"],"sourcesContent":["/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { gosNREUM } from '../window/nreum'\nimport { getOrSet } from '../util/get-or-set'\nimport { mapOwn } from '../util/map-own'\n\nvar ctxId = 'nr@context'\n\n// create global emitter instance that can be shared among bundles\nlet nr = gosNREUM()\nvar globalInstance\nif (nr.ee) {\n  globalInstance = nr.ee\n} else {\n  globalInstance = ee(undefined, 'globalEE')\n  nr.ee = globalInstance\n}\n\n// export default ee()\nvar baseEE = ee(undefined, 'baseEE')\n\nexport { baseEE as ee }\n\nexport { globalInstance as global }\n\nfunction EventContext () {}\n\nfunction ee (old, debugId) {\n  var handlers = {}\n  var bufferGroupMap = {}\n  var emitters = {}\n\n  var emitter = {\n    on: addEventListener,\n    addEventListener: addEventListener,\n    removeEventListener: removeEventListener,\n    emit: emit,\n    get: getOrCreate,\n    listeners: listeners,\n    context: context,\n    buffer: bufferEventsByGroup,\n    abort: abortIfNotLoaded,\n    aborted: false,\n    isBuffering: isBuffering,\n    debugId\n  }\n\n  // buffer is associated with a base emitter, since there are two\n  // (global and scoped to the current bundle), it is now part of the emitter\n  if (!old) {\n    emitter.backlog = {}\n  }\n\n  return emitter\n\n  function context (contextOrStore) {\n    if (contextOrStore && contextOrStore instanceof EventContext) {\n      return contextOrStore\n    } else if (contextOrStore) {\n      return getOrSet(contextOrStore, ctxId, getNewContext)\n    } else {\n      return getNewContext()\n    }\n  }\n\n  function emit (type, args, contextOrStore, force, bubble) {\n    if (bubble !== false) bubble = true\n    if (baseEE.aborted && !force) { return }\n    if (old && bubble) old.emit(type, args, contextOrStore)\n    // log(\"continue...\")\n\n    var ctx = context(contextOrStore)\n    var handlersArray = listeners(type)\n    var len = handlersArray.length\n\n    // Extremely verbose debug logging\n    // if ([/^xhr/].map(function (match) {return type.match(match)}).filter(Boolean).length) {\n    //  log(type + ' args:')\n    //  log(args)\n    //  log(type + ' handlers array:')\n    //  log(handlersArray)\n    //  log(type + ' context:')\n    //  log(ctx)\n    //  log(type + ' ctxStore:')\n    //  log(ctxStore)\n    // }\n\n    // Apply each handler function in the order they were added\n    // to the context with the arguments\n\n    for (var i = 0; i < len; i++) handlersArray[i].apply(ctx, args)\n\n    // log(bufferGroupMap[type])\n    // Buffer after emitting for consistent ordering\n    var bufferGroup = getBuffer()[bufferGroupMap[type]]\n    if (bufferGroup) {\n      bufferGroup.push([emitter, type, args, ctx])\n    }\n\n    // log(bufferGroup)\n\n    // Return the context so that the module that emitted can see what was done.\n    return ctx\n  }\n\n  function addEventListener (type, fn) {\n    // Retrieve type from handlers, if it doesn't exist assign the default and retrieve it.\n    handlers[type] = listeners(type).concat(fn)\n  }\n\n  function removeEventListener (type, fn) {\n    var listeners = handlers[type]\n    if (!listeners) return\n    for (var i = 0; i < listeners.length; i++) {\n      if (listeners[i] === fn) {\n        listeners.splice(i, 1)\n      }\n    }\n  }\n\n  function listeners (type) {\n    return handlers[type] || []\n  }\n\n  function getOrCreate (name) {\n    return (emitters[name] = emitters[name] || ee(emitter, name))\n  }\n\n  function bufferEventsByGroup (types, group) {\n    var eventBuffer = getBuffer()\n\n    // do not buffer events if agent has been aborted\n    if (emitter.aborted) return\n    mapOwn(types, function (i, type) {\n      group = group || 'feature'\n      bufferGroupMap[type] = group\n      if (!(group in eventBuffer)) {\n        eventBuffer[group] = []\n      }\n    })\n  }\n\n  function isBuffering(type) {\n    var bufferGroup = getBuffer()[bufferGroupMap[type]]\n    return !!bufferGroup\n  }\n\n  // buffer is associated with a base emitter, since there are two\n  // (global and scoped to the current bundle), it is now part of the emitter\n  function getBuffer() {\n    if (old) {\n      return old.backlog\n    }\n    return emitter.backlog\n  }\n}\n\n// get context object from store object, or create if does not exist\nexport function getOrSetContext(obj) {\n  return getOrSet(obj, ctxId, getNewContext)\n}\n\nfunction getNewContext () {\n  return new EventContext()\n}\n\n// abort should be called 30 seconds after the page has started running\n// We should drop our data and stop collecting if we still have a backlog, which\n// signifies the rest of the agent wasn't loaded\nfunction abortIfNotLoaded () {\n  if (baseEE.backlog.api || baseEE.backlog.feature) {\n    baseEE.aborted = true\n    baseEE.backlog = {}\n  }\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ee as eePkg, global } from './contextual-ee'\nexport var handleEE = eePkg.get('handle')\nexport var globalEE = global.get('handle')\n\n// Exported for register-handler to attach to.\n// export default handle\nexport { globalHandle as global }\n\nexport function handle(type, args, ctx, group, ee) {\n  if (ee) {\n    ee.buffer([type], group)\n    ee.emit(type, args, ctx)\n  } else {\n    handleEE.buffer([type], group)\n    handleEE.emit(type, args, ctx)\n  }\n}\n\nfunction globalHandle(type, args, ctx, group) {\n  globalEE.buffer([type], group)\n  globalEE.emit(type, args, ctx)\n}\n","var supportsPassive = false\ntry {\n  var opts = Object.defineProperty({}, 'passive', {\n    // eslint-disable-next-line\n    get: function() {\n      supportsPassive = true\n    }\n  })\n  window.addEventListener('testPassive', null, opts)\n  window.removeEventListener('testPassive', null, opts)\n} catch (e) {\n  // do nothing\n}\n\nexport function eventListenerOpts(useCapture) {\n  return supportsPassive ? {passive: true, capture: !!useCapture} : !!useCapture\n}\n\n// export default eventListenerOpts\n","import {ee} from '../event-emitter/contextual-ee'\n\nexport class FeatureBase {\n  constructor(agentIdentifier, aggregator) {\n    this.agentIdentifier = agentIdentifier\n    this.aggregator = aggregator\n    this.ee = ee.get(agentIdentifier)\n  }\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar has = Object.prototype.hasOwnProperty\n\n// export default getOrSet\n\n// Always returns the current value of obj[prop], even if it has to set it first\nexport function getOrSet (obj, prop, getVal) {\n  // If the value exists return it.\n  if (has.call(obj, prop)) return obj[prop]\n\n  var val = getVal()\n\n  // Attempt to set the property so it's not enumerable\n  if (Object.defineProperty && Object.keys) {\n    try {\n      Object.defineProperty(obj, prop, {\n        value: val, // old IE inherits non-write-ability\n        writable: true,\n        enumerable: false\n      })\n\n      return val\n    } catch (e) {\n      // Can't report internal errors,\n      // because GOS is a dependency of the reporting mechanisms\n    }\n  }\n\n  // fall back to setting normally\n  obj[prop] = val\n  return val\n}\n","import { eventListenerOpts } from '../event-listener/event-listener-opts'\n\nconst win = window\nconst doc = win.document\nconst ADD_EVENT_LISTENER = 'addEventListener'\nconst ATTACH_EVENT = 'attachEvent'\n\nfunction stateChange (cb) {\n  if (doc.readyState === 'complete') cb()\n}\n\nexport function onWindowLoad(cb) {\n  if (doc[ADD_EVENT_LISTENER]) win[ADD_EVENT_LISTENER]('load', cb, eventListenerOpts(false))\n  else win[ATTACH_EVENT]('onload', cb)\n}\n\nexport function onDOMContentLoaded(cb) {\n  if (doc[ADD_EVENT_LISTENER]) doc[ADD_EVENT_LISTENER]('DOMContentLoaded', cb, eventListenerOpts(false))\n  else doc[ATTACH_EVENT]('onreadystatechange', stateChange)\n}\n\n","\nimport { handle } from '../../../common/event-emitter/handle'\nimport { now, getOffset, getLastTimestamp } from '../../../common/timing/now'\nimport { FeatureBase } from '../../../common/util/feature-base'\nimport { onDOMContentLoaded, onWindowLoad } from '../../../common/window/load'\n\nexport class Instrument extends FeatureBase {\n  constructor(agentIdentifier) {\n    super(agentIdentifier)\n    handle('mark', ['firstbyte', getLastTimestamp()], null, 'api', this.ee)\n\n    onWindowLoad(() => this.measureWindowLoaded())\n    onDOMContentLoaded(() => this.measureDomContentLoaded())\n  }\n\n  measureWindowLoaded() {\n    var ts = now()\n    handle('mark', ['onload', ts + getOffset()], null, 'api', this.ee)\n    handle('timing', ['load', ts], undefined, undefined, this.ee)\n  }\n\n  measureDomContentLoaded() {\n    handle('mark', ['domContent', now() + getOffset()], null, 'api', this.ee)\n  }\n}\n"],"names":["ctxId","nr","globalInstance","ee","undefined","baseEE","EventContext","old","debugId","handlers","bufferGroupMap","emitters","emitter","on","addEventListener","removeEventListener","type","fn","listeners","i","length","splice","emit","args","contextOrStore","force","bubble","aborted","ctx","context","handlersArray","len","apply","bufferGroup","getBuffer","push","get","getOrCreate","name","buffer","bufferEventsByGroup","types","group","eventBuffer","abort","abortIfNotLoaded","isBuffering","backlog","getNewContext","concat","api","feature","handleEE","globalEE","handle","supportsPassive","opts","Object","defineProperty","window","e","eventListenerOpts","useCapture","passive","capture","FeatureBase","constructor","agentIdentifier","aggregator","this","has","prototype","hasOwnProperty","getOrSet","obj","prop","getVal","call","val","keys","value","writable","enumerable","win","doc","document","ADD_EVENT_LISTENER","ATTACH_EVENT","stateChange","cb","readyState","Instrument","super","onWindowLoad","measureWindowLoaded","onDOMContentLoaded","measureDomContentLoaded","ts","now"],"sourceRoot":""}