{"version":3,"file":"311.talkdeskchatsdk.js","mappings":"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","sources":["webpack://TalkdeskChatSDK/./node_modules/@newrelic/browser-agent-core/common/config/state/originals.js","webpack://TalkdeskChatSDK/./node_modules/@newrelic/browser-agent-core/common/event-emitter/contextual-ee.js","webpack://TalkdeskChatSDK/./node_modules/@newrelic/browser-agent-core/common/event-emitter/handle.js","webpack://TalkdeskChatSDK/./node_modules/@newrelic/browser-agent-core/common/event-listener/event-listener-opts.js","webpack://TalkdeskChatSDK/./node_modules/@newrelic/browser-agent-core/common/util/feature-base.js","webpack://TalkdeskChatSDK/./node_modules/@newrelic/browser-agent-core/common/util/get-or-set.js","webpack://TalkdeskChatSDK/./node_modules/@newrelic/browser-agent-core/common/wrap/wrap-fetch.js","webpack://TalkdeskChatSDK/./node_modules/@newrelic/browser-agent-core/common/wrap/wrap-function.js","webpack://TalkdeskChatSDK/./node_modules/@newrelic/browser-agent-core/common/wrap/wrap-timer.js","webpack://TalkdeskChatSDK/./node_modules/@newrelic/browser-agent-core/common/wrap/wrap-raf.js","webpack://TalkdeskChatSDK/./node_modules/@newrelic/browser-agent-core/common/wrap/wrap-history.js","webpack://TalkdeskChatSDK/./node_modules/@newrelic/browser-agent-core/common/wrap/wrap-xhr.js","webpack://TalkdeskChatSDK/./node_modules/@newrelic/browser-agent-core/common/wrap/wrap-events.js","webpack://TalkdeskChatSDK/./node_modules/@newrelic/browser-agent-core/common/wrap/index.js","webpack://TalkdeskChatSDK/./node_modules/lodash._slice/index.js"],"sourcesContent":["import { gosNREUMOriginals } from '../../window/nreum'\n\nexport const originals = gosNREUMOriginals().o\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { gosNREUM } from '../window/nreum'\nimport { getOrSet } from '../util/get-or-set'\nimport { mapOwn } from '../util/map-own'\n\nvar ctxId = 'nr@context'\n\n// create global emitter instance that can be shared among bundles\nlet nr = gosNREUM()\nvar globalInstance\nif (nr.ee) {\n  globalInstance = nr.ee\n} else {\n  globalInstance = ee(undefined, 'globalEE')\n  nr.ee = globalInstance\n}\n\n// export default ee()\nvar baseEE = ee(undefined, 'baseEE')\n\nexport { baseEE as ee }\n\nexport { globalInstance as global }\n\nfunction EventContext () {}\n\nfunction ee (old, debugId) {\n  var handlers = {}\n  var bufferGroupMap = {}\n  var emitters = {}\n\n  var emitter = {\n    on: addEventListener,\n    addEventListener: addEventListener,\n    removeEventListener: removeEventListener,\n    emit: emit,\n    get: getOrCreate,\n    listeners: listeners,\n    context: context,\n    buffer: bufferEventsByGroup,\n    abort: abortIfNotLoaded,\n    aborted: false,\n    isBuffering: isBuffering,\n    debugId\n  }\n\n  // buffer is associated with a base emitter, since there are two\n  // (global and scoped to the current bundle), it is now part of the emitter\n  if (!old) {\n    emitter.backlog = {}\n  }\n\n  return emitter\n\n  function context (contextOrStore) {\n    if (contextOrStore && contextOrStore instanceof EventContext) {\n      return contextOrStore\n    } else if (contextOrStore) {\n      return getOrSet(contextOrStore, ctxId, getNewContext)\n    } else {\n      return getNewContext()\n    }\n  }\n\n  function emit (type, args, contextOrStore, force, bubble) {\n    if (bubble !== false) bubble = true\n    if (baseEE.aborted && !force) { return }\n    if (old && bubble) old.emit(type, args, contextOrStore)\n    // log(\"continue...\")\n\n    var ctx = context(contextOrStore)\n    var handlersArray = listeners(type)\n    var len = handlersArray.length\n\n    // Extremely verbose debug logging\n    // if ([/^xhr/].map(function (match) {return type.match(match)}).filter(Boolean).length) {\n    //  log(type + ' args:')\n    //  log(args)\n    //  log(type + ' handlers array:')\n    //  log(handlersArray)\n    //  log(type + ' context:')\n    //  log(ctx)\n    //  log(type + ' ctxStore:')\n    //  log(ctxStore)\n    // }\n\n    // Apply each handler function in the order they were added\n    // to the context with the arguments\n\n    for (var i = 0; i < len; i++) handlersArray[i].apply(ctx, args)\n\n    // log(bufferGroupMap[type])\n    // Buffer after emitting for consistent ordering\n    var bufferGroup = getBuffer()[bufferGroupMap[type]]\n    if (bufferGroup) {\n      bufferGroup.push([emitter, type, args, ctx])\n    }\n\n    // log(bufferGroup)\n\n    // Return the context so that the module that emitted can see what was done.\n    return ctx\n  }\n\n  function addEventListener (type, fn) {\n    // Retrieve type from handlers, if it doesn't exist assign the default and retrieve it.\n    handlers[type] = listeners(type).concat(fn)\n  }\n\n  function removeEventListener (type, fn) {\n    var listeners = handlers[type]\n    if (!listeners) return\n    for (var i = 0; i < listeners.length; i++) {\n      if (listeners[i] === fn) {\n        listeners.splice(i, 1)\n      }\n    }\n  }\n\n  function listeners (type) {\n    return handlers[type] || []\n  }\n\n  function getOrCreate (name) {\n    return (emitters[name] = emitters[name] || ee(emitter, name))\n  }\n\n  function bufferEventsByGroup (types, group) {\n    var eventBuffer = getBuffer()\n\n    // do not buffer events if agent has been aborted\n    if (emitter.aborted) return\n    mapOwn(types, function (i, type) {\n      group = group || 'feature'\n      bufferGroupMap[type] = group\n      if (!(group in eventBuffer)) {\n        eventBuffer[group] = []\n      }\n    })\n  }\n\n  function isBuffering(type) {\n    var bufferGroup = getBuffer()[bufferGroupMap[type]]\n    return !!bufferGroup\n  }\n\n  // buffer is associated with a base emitter, since there are two\n  // (global and scoped to the current bundle), it is now part of the emitter\n  function getBuffer() {\n    if (old) {\n      return old.backlog\n    }\n    return emitter.backlog\n  }\n}\n\n// get context object from store object, or create if does not exist\nexport function getOrSetContext(obj) {\n  return getOrSet(obj, ctxId, getNewContext)\n}\n\nfunction getNewContext () {\n  return new EventContext()\n}\n\n// abort should be called 30 seconds after the page has started running\n// We should drop our data and stop collecting if we still have a backlog, which\n// signifies the rest of the agent wasn't loaded\nfunction abortIfNotLoaded () {\n  if (baseEE.backlog.api || baseEE.backlog.feature) {\n    baseEE.aborted = true\n    baseEE.backlog = {}\n  }\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ee as eePkg, global } from './contextual-ee'\nexport var handleEE = eePkg.get('handle')\nexport var globalEE = global.get('handle')\n\n// Exported for register-handler to attach to.\n// export default handle\nexport { globalHandle as global }\n\nexport function handle(type, args, ctx, group, ee) {\n  if (ee) {\n    ee.buffer([type], group)\n    ee.emit(type, args, ctx)\n  } else {\n    handleEE.buffer([type], group)\n    handleEE.emit(type, args, ctx)\n  }\n}\n\nfunction globalHandle(type, args, ctx, group) {\n  globalEE.buffer([type], group)\n  globalEE.emit(type, args, ctx)\n}\n","var supportsPassive = false\ntry {\n  var opts = Object.defineProperty({}, 'passive', {\n    // eslint-disable-next-line\n    get: function() {\n      supportsPassive = true\n    }\n  })\n  window.addEventListener('testPassive', null, opts)\n  window.removeEventListener('testPassive', null, opts)\n} catch (e) {\n  // do nothing\n}\n\nexport function eventListenerOpts(useCapture) {\n  return supportsPassive ? {passive: true, capture: !!useCapture} : !!useCapture\n}\n\n// export default eventListenerOpts\n","import {ee} from '../event-emitter/contextual-ee'\n\nexport class FeatureBase {\n  constructor(agentIdentifier, aggregator) {\n    this.agentIdentifier = agentIdentifier\n    this.aggregator = aggregator\n    this.ee = ee.get(agentIdentifier)\n  }\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar has = Object.prototype.hasOwnProperty\n\n// export default getOrSet\n\n// Always returns the current value of obj[prop], even if it has to set it first\nexport function getOrSet (obj, prop, getVal) {\n  // If the value exists return it.\n  if (has.call(obj, prop)) return obj[prop]\n\n  var val = getVal()\n\n  // Attempt to set the property so it's not enumerable\n  if (Object.defineProperty && Object.keys) {\n    try {\n      Object.defineProperty(obj, prop, {\n        value: val, // old IE inherits non-write-ability\n        writable: true,\n        enumerable: false\n      })\n\n      return val\n    } catch (e) {\n      // Can't report internal errors,\n      // because GOS is a dependency of the reporting mechanisms\n    }\n  }\n\n  // fall back to setting normally\n  obj[prop] = val\n  return val\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {ee as baseEE} from '../event-emitter/contextual-ee'\nimport slice from 'lodash._slice'\nimport {mapOwn} from '../util/map-own'\nimport { originals } from '../config/config'\n\n\nvar win = window\nvar prefix = 'fetch-'\nvar bodyPrefix = prefix + 'body-'\nvar bodyMethods = ['arrayBuffer', 'blob', 'json', 'text', 'formData']\nvar Req = win.Request\nvar Res = win.Response\n// var fetch = win.fetch\nvar proto = 'prototype'\nvar ctxId = 'nr@context'\n\nexport function wrapGlobal() {\n  // since these are prototype methods, we can only wrap globally\n  mapOwn(bodyMethods, function (i, name) {\n    wrapPromiseMethod(baseEE, Req[proto], name, bodyPrefix)\n    wrapPromiseMethod(baseEE, Res[proto], name, bodyPrefix)\n  })\n\n  var wrappedFetch = wrapFetch(baseEE)\n  win.fetch = wrappedFetch\n}\n\nexport function wrapFetch(sharedEE) {\n  var fn = originals.FETCH\n  var ee = (sharedEE || baseEE)\n\n  var wrappedFetch = wrapPromiseMethod(ee, fn, prefix)\n\n  ee.on(prefix + 'end', function (err, res) {\n    var ctx = this\n    if (res) {\n      var size = res.headers.get('content-length')\n      if (size !== null) {\n        ctx.rxSize = size\n      }\n      ee.emit(prefix + 'done', [null, res], ctx)\n    } else {\n      ee.emit(prefix + 'done', [err], ctx)\n    }\n  })\n\n  return wrappedFetch\n}\n\n// this should probably go to the common module as a part of wrapping utility functions\nfunction wrapPromiseMethod(ee, fn, prefix) {\n  return function nrWrapper() {\n    var args = slice(arguments)\n\n    var ctx = {}\n    // we are wrapping args in an array so we can preserve the reference\n    ee.emit(prefix + 'before-start', [args], ctx)\n    var dtPayload\n    if (ctx[ctxId] && ctx[ctxId].dt) dtPayload = ctx[ctxId].dt\n\n    var promise = fn.apply(this, args)\n\n    ee.emit(prefix + 'start', [args, dtPayload], promise)\n\n    return promise.then(function (val) {\n      ee.emit(prefix + 'end', [null, val], promise)\n      return val\n    }, function (err) {\n      ee.emit(prefix + 'end', [err], promise)\n      throw err\n    })\n  }\n}\n\n\nexport function scopedEE(sharedEE){\n  return (sharedEE || baseEE).get('events')\n}","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {ee} from '../event-emitter/contextual-ee'\nimport slice from 'lodash._slice'\nvar flag = 'nr@original'\nvar has = Object.prototype.hasOwnProperty\nvar inWrapper = false\n\n// eslint-disable-next-line\nexport default createWrapperWithEmitter\n\nexport function createWrapperWithEmitter(emitter, always) {\n  emitter || (emitter = ee)\n\n  wrapFn.inPlace = inPlace\n  wrapFn.flag = flag\n\n  return wrapFn\n\n  function wrapFn (fn, prefix, getContext, methodName, bubble) {\n    // Unless fn is both wrappable and unwrapped, return it unchanged.\n    if (notWrappable(fn)) return fn\n\n    if (!prefix) prefix = ''\n\n    nrWrapper[flag] = fn\n    copy(fn, nrWrapper, emitter)\n    return nrWrapper\n\n    function nrWrapper () {\n      var args\n      var originalThis\n      var ctx\n      var result\n\n      try {\n        originalThis = this\n        args = slice(arguments)\n\n        if (typeof getContext === 'function') {\n          ctx = getContext(args, originalThis)\n        } else {\n          ctx = getContext || {}\n        }\n      } catch (e) {\n        report([e, '', [args, originalThis, methodName], ctx], emitter)\n      }\n\n      // Warning: start events may mutate args!\n      safeEmit(prefix + 'start', [args, originalThis, methodName], ctx, bubble)\n\n      try {\n        result = fn.apply(originalThis, args)\n        return result\n      } catch (err) {\n        safeEmit(prefix + 'err', [args, originalThis, err], ctx, bubble)\n\n        // rethrow error so we don't effect execution by observing.\n        throw err\n      } finally {\n        // happens no matter what.\n        safeEmit(prefix + 'end', [args, originalThis, result], ctx, bubble)\n      }\n    }\n  }\n\n  function inPlace (obj, methods, prefix, getContext, bubble) {\n    // log('methods!', methods)\n    if (!prefix) prefix = ''\n    // If prefix starts with '-' set this boolean to add the method name to\n    // the prefix before passing each one to wrap.\n    var prependMethodPrefix = (prefix.charAt(0) === '-')\n    var fn\n    var method\n    var i\n\n    for (i = 0; i < methods.length; i++) {\n      method = methods[i]\n      fn = obj[method]\n\n      // Unless fn is both wrappable and unwrapped bail,\n      // so we don't add extra properties with undefined values.\n      if (notWrappable(fn)) continue\n\n      obj[method] = wrapFn(fn, (prependMethodPrefix ? method + prefix : prefix), getContext, method, bubble)\n    }\n  }\n\n  function safeEmit (evt, arr, store, bubble) {\n    if (inWrapper && !always) return\n    var prev = inWrapper\n    inWrapper = true\n    try {\n      emitter.emit(evt, arr, store, always, bubble)\n    } catch (e) {\n      report([e, evt, arr, store], emitter)\n    }\n    inWrapper = prev\n  }\n}\n\nfunction report (args, emitter) {\n  emitter || (emitter = ee)\n  try {\n    emitter.emit('internal-error', args)\n  } catch (err) {\n    // do nothing\n  }\n}\n\nfunction copy (from, to, emitter) {\n  if (Object.defineProperty && Object.keys) {\n    // Create accessors that proxy to actual function\n    try {\n      var keys = Object.keys(from)\n      // eslint-disable-next-line\n      keys.forEach(function (key) {\n        Object.defineProperty(to, key, {\n          get: function () { return from[key] },\n          // eslint-disable-next-line\n          set: function (val) { from[key] = val; return val }\n        })\n      })\n      return to\n    } catch (e) {\n      report([e], emitter)\n    }\n  }\n  // fall back to copying properties\n  for (var i in from) {\n    if (has.call(from, i)) {\n      to[i] = from[i]\n    }\n  }\n  return to\n}\n\nfunction notWrappable (fn) {\n  return !(fn && fn instanceof Function && fn.apply && !fn[flag])\n}\n\nexport function wrapFunction(fn, wrapper) {\n  var wrapped = wrapper(fn)\n  wrapped[flag] = fn\n  copy(fn, wrapped, ee)\n  return wrapped\n}\n\nexport function wrapInPlace(obj, fnName, wrapper) {\n  var fn = obj[fnName]\n  obj[fnName] = wrapFunction(fn, wrapper)\n}\n\nexport function argsToArray() {\n  var len = arguments.length\n  var arr = new Array(len)\n  for (var i = 0; i < len; ++i) {\n    arr[i] = arguments[i]\n  }\n  return arr\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ee as baseEE } from '../event-emitter/contextual-ee'\nimport { createWrapperWithEmitter as wfn } from './wrap-function'\n\n//eslint-disable-next-line\nexport function wrapTimer(sharedEE) {\n  var ee = scopedEE(sharedEE)\n  var wrapFn = wfn(ee)\n\n  var SET_TIMEOUT = 'setTimeout'\n  var SET_INTERVAL = 'setInterval'\n  var CLEAR_TIMEOUT = 'clearTimeout'\n  var START = '-start'\n  var DASH = '-'\n\n  // log('wrap timer...')\n  wrapFn.inPlace(window, [SET_TIMEOUT, 'setImmediate'], SET_TIMEOUT + DASH)\n  wrapFn.inPlace(window, [SET_INTERVAL], SET_INTERVAL + DASH)\n  wrapFn.inPlace(window, [CLEAR_TIMEOUT, 'clearImmediate'], CLEAR_TIMEOUT + DASH)\n\n  ee.on(SET_INTERVAL + START, interval)\n  ee.on(SET_TIMEOUT + START, timer)\n\n  function interval(args, obj, type) {\n    args[0] = wrapFn(args[0], 'fn-', null, type)\n  }\n\n  function timer(args, obj, type) {\n    this.method = type\n    this.timerDuration = isNaN(args[1]) ? 0 : +args[1]\n    args[0] = wrapFn(args[0], 'fn-', this, type)\n  }\n\n  return ee\n}\n\nexport function scopedEE(sharedEE){\n  return (sharedEE || baseEE).get('timer')\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// Request Animation Frame wrapper\nimport { ee as baseEE } from '../event-emitter/contextual-ee'\nimport { createWrapperWithEmitter as wfn } from './wrap-function'\n\nexport function wrapRaf(sharedEE) {\n  var ee = scopedEE(sharedEE)\n  var wrapFn = wfn(ee)\n\n  var equestAnimationFrame = 'equestAnimationFrame'\n\n  wrapFn.inPlace(window, [\n    'r' + equestAnimationFrame,\n    'mozR' + equestAnimationFrame,\n    'webkitR' + equestAnimationFrame,\n    'msR' + equestAnimationFrame\n  ], 'raf-')\n\n  ee.on('raf-start', function (args) {\n    // Wrap the callback handed to requestAnimationFrame\n    args[0] = wrapFn(args[0], 'fn-')\n  })\n\n  return ee\n}\n\nexport function scopedEE(sharedEE){\n  return (sharedEE || baseEE).get('raf')\n}\n","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// History pushState wrapper\nimport {ee as baseEE} from '../event-emitter/contextual-ee'\nimport {createWrapperWithEmitter as wfn} from './wrap-function'\n\nexport function wrapHistory(sharedEE){\n  var ee = scopedEE(sharedEE)\n  var wrapFn = wfn(ee)\n  \n  var prototype = window.history && window.history.constructor && window.history.constructor.prototype\n  var object = window.history\n  if (prototype && prototype.pushState && prototype.replaceState) {\n    object = prototype\n  }\n  // log('wrap history')\n  wrapFn.inPlace(object, [ 'pushState', 'replaceState' ], '-')\n\n  return ee\n}\n3\nexport function scopedEE(sharedEE){\n  return (sharedEE || baseEE).get('history')\n}","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// wrap-events patches XMLHttpRequest.prototype.addEventListener for us.\nimport './wrap-events'\n// import * as config from '../config'\nimport {ee as contextualEE} from '../event-emitter/contextual-ee'\nimport { eventListenerOpts } from '../event-listener/event-listener-opts'\nimport { createWrapperWithEmitter as wfn } from './wrap-function'\nimport { originals } from '../config/config'\n\n// eslint-disable-next-line\nexport function wrapXhr (sharedEE) {\n  var baseEE = sharedEE || contextualEE\n  var ee = scopedEE(baseEE)\n  var wrapFn = wfn(ee)\n\n  var OrigXHR = originals.XHR\n  var MutationObserver = originals.MO\n  var Promise = originals.PR\n  var setImmediate = originals.SI\n\n  var READY_STATE_CHANGE = 'readystatechange'\n\n  var handlers = ['onload', 'onerror', 'onabort', 'onloadstart', 'onloadend', 'onprogress', 'ontimeout']\n  var pendingXhrs = []\n\n  var XHR = window.XMLHttpRequest = function (opts) {\n    var xhr = new OrigXHR(opts)\n    try {\n      ee.emit('new-xhr', [xhr], xhr)\n      xhr.addEventListener(READY_STATE_CHANGE, wrapXHR, eventListenerOpts(false))\n    } catch (e) {\n      try {\n        ee.emit('internal-error', [e])\n      } catch (err) {\n        // do nothing\n      }\n    }\n    return xhr\n  }\n\n  copy(OrigXHR, XHR)\n\n  XHR.prototype = OrigXHR.prototype\n\n  // log('wrap xhr...')\n  wrapFn.inPlace(XHR.prototype, ['open', 'send'], '-xhr-', getObject)\n\n  ee.on('send-xhr-start', function (args, xhr) {\n    wrapOnreadystatechange(args, xhr)\n    enqueuePendingXhr(xhr)\n  })\n  ee.on('open-xhr-start', wrapOnreadystatechange)\n\n  function wrapOnreadystatechange(args, xhr) {\n    wrapFn.inPlace(xhr, ['onreadystatechange'], 'fn-', getObject)\n  }\n\n  function wrapXHR() {\n    var xhr = this\n    var ctx = ee.context(xhr)\n\n    if (xhr.readyState > 3 && !ctx.resolved) {\n      ctx.resolved = true\n      ee.emit('xhr-resolved', [], xhr)\n    }\n\n    wrapFn.inPlace(xhr, handlers, 'fn-', getObject)\n  }\n\n  // Wrapping the onreadystatechange property of XHRs takes some special tricks.\n  //\n  // The issue is that the onreadystatechange property may be assigned *after*\n  // send() is called against an XHR. This is of particular importance because\n  // jQuery uses a single onreadystatechange handler to implement all of the XHR\n  // callbacks thtat it provides, and it assigns that property after calling send.\n  //\n  // There are several 'obvious' approaches to wrapping the onreadystatechange\n  // when it's assigned after send:\n  //\n  // 1. Try to wrap the onreadystatechange handler from a readystatechange\n  //    addEventListener callback (the addEventListener callback will fire before\n  //    the onreadystatechange callback).\n  //\n  //      Caveat: this doesn't work in Chrome or Safari, and in fact will cause\n  //      the onreadystatechange handler to not be invoked at all during the\n  //      firing cycle in which it is wrapped, which may break applications :(\n  //\n  // 2. Use Object.defineProperty to create a setter for the onreadystatechange\n  //    property, and wrap from that setter.\n  //\n  //      Caveat: onreadystatechange is not a configurable property in Safari or\n  //      older versions of the Android browser.\n  //\n  // 3. Schedule wrapping of the onreadystatechange property using a setTimeout\n  //    call issued just before the call to send.\n  //\n  //      Caveat: sometimes, the onreadystatechange handler fires before the\n  //      setTimeout, meaning the wrapping happens too late.\n  //\n  // The setTimeout approach is closest to what we use here: we want to schedule\n  // the wrapping of the onreadystatechange property when send is called, but\n  // ensure that our wrapping happens before onreadystatechange has a chance to\n  // fire.\n  //\n  // We achieve this using a hybrid approach:\n  //\n  // * In browsers that support MutationObserver, we use that to schedule wrapping\n  //   of onreadystatechange.\n  //\n  // * We have discovered that MutationObserver in IE causes a memory leak, so we\n  //   now will prefer setImmediate for IE, and use a resolved promise to schedule\n  //   the wrapping in Edge (and other browsers that support promises)\n  //\n  // * In older browsers that don't support MutationObserver, we rely on the fact\n  //   that the call to send is probably happening within a callback that we've\n  //   already wrapped, and use our existing fn-end event callback to wrap the\n  //   onreadystatechange at the end of the current callback.\n  //\n\n  if (MutationObserver) {\n    var resolved = Promise && Promise.resolve()\n    if (!setImmediate && !Promise) {\n      var toggle = 1\n      var dummyNode = document.createTextNode(toggle)\n      new MutationObserver(drainPendingXhrs).observe(dummyNode, { characterData: true })\n    }\n  } else {\n    baseEE.on('fn-end', function (args) {\n      // We don't want to try to wrap onreadystatechange from within a\n      // readystatechange callback.\n      if (args[0] && args[0].type === READY_STATE_CHANGE) return\n      drainPendingXhrs()\n    })\n  }\n\n  function enqueuePendingXhr(xhr) {\n    pendingXhrs.push(xhr)\n    if (MutationObserver) {\n      if (resolved) {\n        resolved.then(drainPendingXhrs)\n      } else if (setImmediate) {\n        setImmediate(drainPendingXhrs)\n      } else {\n        toggle = -toggle\n        dummyNode.data = toggle\n      }\n    }\n  }\n\n  function drainPendingXhrs() {\n    for (var i = 0; i < pendingXhrs.length; i++) {\n      wrapOnreadystatechange([], pendingXhrs[i])\n    }\n    if (pendingXhrs.length) pendingXhrs = []\n  }\n\n  // Use the object these methods are on as their\n  // context store for the event emitter\n  function getObject(args, obj) {\n    return obj\n  }\n\n  function copy(from, to) {\n    for (var i in from) {\n      to[i] = from[i]\n    }\n    return to\n  }\n\n  return ee\n}\n\n\nexport function scopedEE(sharedEE){\n  return (sharedEE || contextualEE).get('events')\n}","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {ee as baseEE} from '../event-emitter/contextual-ee'\nimport { createWrapperWithEmitter as wfn } from './wrap-function'\nimport { getOrSet } from '../util/get-or-set'\n\nexport function wrapEvents(sharedEE) {\n  var ee = scopedEE(sharedEE)\n  var wrapFn = wfn(ee, true)\n\n  var XHR = XMLHttpRequest\n  var ADD_EVENT_LISTENER = 'addEventListener'\n  var REMOVE_EVENT_LISTENER = 'removeEventListener'\n\n  // Guard against instrumenting environments w/o necessary features\n  if ('getPrototypeOf' in Object) {\n    findAndWrapNode(document)\n    findAndWrapNode(window)\n    findAndWrapNode(XHR.prototype)\n    // eslint-disable-next-line\n  } else if (XHR.prototype.hasOwnProperty(ADD_EVENT_LISTENER)) {\n    wrapNode(window)\n    wrapNode(XHR.prototype)\n  }\n\n  ee.on(ADD_EVENT_LISTENER + '-start', function (args, target) {\n    var originalListener = args[1]\n    if (originalListener === null ||\n      (typeof originalListener !== 'function' && typeof originalListener !== 'object')\n    ) {\n      return\n    }\n\n    var wrapped = getOrSet(originalListener, 'nr@wrapped', function () {\n      var listener = {\n        object: wrapHandleEvent,\n        'function': originalListener\n      }[typeof originalListener]\n\n      return listener ? wrapFn(listener, 'fn-', null, (listener.name || 'anonymous')) : originalListener\n\n      function wrapHandleEvent() {\n        if (typeof originalListener.handleEvent !== 'function') return\n        return originalListener.handleEvent.apply(originalListener, arguments)\n      }\n    })\n\n    this.wrapped = args[1] = wrapped\n  })\n\n  ee.on(REMOVE_EVENT_LISTENER + '-start', function (args) {\n    args[1] = this.wrapped || args[1]\n  })\n\n  function findAndWrapNode(object) {\n    var step = object\n    // eslint-disable-next-line\n    while (step && !step.hasOwnProperty(ADD_EVENT_LISTENER)) { step = Object.getPrototypeOf(step) }\n    if (step) { wrapNode(step) }\n  }\n\n  function wrapNode(node) {\n    wrapFn.inPlace(node, [ADD_EVENT_LISTENER, REMOVE_EVENT_LISTENER], '-', uniqueListener)\n  }\n\n  function uniqueListener(args, obj) {\n    // Context for the listener is stored on itself.\n    return args[1]\n  }\n\n  return ee\n}\n\nexport function scopedEE(sharedEE){\n  return (sharedEE || baseEE).get('events')\n}\n\n","\nimport {wrapFetch as wf} from './wrap-fetch'\nimport {wrapTimer as wt} from './wrap-timer'\nimport {wrapRaf as wr} from './wrap-raf'\nimport {wrapHistory as wh} from './wrap-history'\nimport {wrapJsonP as wj} from './wrap-jsonp'\nimport {wrapMutation as wm} from './wrap-mutation'\nimport {wrapPromise as wp} from './wrap-promise'\nimport {wrapXhr as wx} from './wrap-xhr'\nimport {wrapEvents as we} from './wrap-events'\n\nexport {wrapGlobal as wrapGlobalFetch} from './wrap-fetch'\n\nexport function wrapEvents(sharedEE) {\n  return we(sharedEE)\n}\n\nexport function wrapFetch(sharedEE) {\n  return wf(sharedEE)\n}\n\nexport function wrapHistory(sharedEE) {\n  return wh(sharedEE)\n}\n\nexport function wrapJson(sharedEE) {\n  return wj(sharedEE)\n}\n\nexport function wrapMutation(sharedEE) {\n  return wm(sharedEE)\n}\n\nexport function wrapPromise(sharedEE) {\n  return wp(sharedEE)\n}\n\nexport function wrapRaf(sharedEE) {\n  return wr(sharedEE)\n}\n\nexport function wrapTimer(sharedEE) {\n  return wt(sharedEE)\n}\n\nexport function wrapXhr(sharedEE) {\n  return wx(sharedEE)\n}\n","/**\n * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>\n * Build: `lodash modularize modern exports=\"npm\" -o ./npm/`\n * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <http://lodash.com/license>\n */\n\n/**\n * Slices the `collection` from the `start` index up to, but not including,\n * the `end` index.\n *\n * Note: This function is used instead of `Array#slice` to support node lists\n * in IE < 9 and to ensure dense arrays are returned.\n *\n * @private\n * @param {Array|Object|string} collection The collection to slice.\n * @param {number} start The start index.\n * @param {number} end The end index.\n * @returns {Array} Returns the new array.\n */\nfunction slice(array, start, end) {\n  start || (start = 0);\n  if (typeof end == 'undefined') {\n    end = array ? array.length : 0;\n  }\n  var index = -1,\n      length = end - start || 0,\n      result = Array(length < 0 ? 0 : length);\n\n  while (++index < length) {\n    result[index] = array[start + index];\n  }\n  return result;\n}\n\nmodule.exports = slice;\n"],"names":["originals","o","ctxId","nr","globalInstance","ee","undefined","baseEE","EventContext","old","debugId","handlers","bufferGroupMap","emitters","emitter","on","addEventListener","removeEventListener","type","fn","listeners","i","length","splice","emit","args","contextOrStore","force","bubble","aborted","ctx","context","handlersArray","len","apply","bufferGroup","getBuffer","push","get","getOrCreate","name","buffer","bufferEventsByGroup","types","group","eventBuffer","abort","abortIfNotLoaded","isBuffering","backlog","getNewContext","concat","api","feature","handleEE","globalEE","handle","supportsPassive","opts","Object","defineProperty","window","e","eventListenerOpts","useCapture","passive","capture","FeatureBase","constructor","agentIdentifier","aggregator","this","has","prototype","hasOwnProperty","getOrSet","obj","prop","getVal","call","val","keys","value","writable","enumerable","win","prefix","Request","Response","wrapFetch","sharedEE","FETCH","wrappedFetch","wrapPromiseMethod","err","res","size","headers","rxSize","nrWrapper","dtPayload","arguments","dt","promise","then","flag","inWrapper","createWrapperWithEmitter","always","wrapFn","inPlace","methods","getContext","method","prependMethodPrefix","charAt","notWrappable","methodName","copy","originalThis","result","report","safeEmit","evt","arr","store","prev","from","to","forEach","key","set","Function","wrapTimer","SET_TIMEOUT","SET_INTERVAL","CLEAR_TIMEOUT","START","interval","timer","timerDuration","isNaN","wrapRaf","equestAnimationFrame","wrapHistory","history","object","pushState","replaceState","wrapXhr","OrigXHR","XHR","MutationObserver","MO","Promise","PR","setImmediate","SI","READY_STATE_CHANGE","pendingXhrs","XMLHttpRequest","xhr","wrapXHR","wrapOnreadystatechange","getObject","readyState","resolved","enqueuePendingXhr","drainPendingXhrs","toggle","dummyNode","data","resolve","document","createTextNode","observe","characterData","wrapEvents","ADD_EVENT_LISTENER","REMOVE_EVENT_LISTENER","findAndWrapNode","step","getPrototypeOf","wrapNode","node","uniqueListener","target","originalListener","wrapped","listener","wrapHandleEvent","handleEvent","module","exports","slice","array","start","end","index","Array"],"sourceRoot":""}